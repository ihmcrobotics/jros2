/*
 * This class was automatically generated by jros2
 */
package visualization_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

public class InteractiveMarker implements ROS2Message<InteractiveMarker>
{
   public static final java.lang.String name = "visualization_msgs::msg::dds_::InteractiveMarker_";

   /**
      Time/frame info.
      If header.time is set to 0, the marker will be retransformed into
      its frame on each timestep. You will receive the pose feedback
      in the same frame.
      Otherwise, you might receive feedback in a different frame.
      For rviz, this will be the current 'fixed frame' set by the user.
   */
   private final std_msgs.msg.dds.Header header_;
   /**
      Initial pose. Also, defines the pivot point for rotations.
   */
   private final geometry_msgs.msg.dds.Pose pose_;
   /**
      Identifying string. Must be globally unique in
      the topic that this message is sent through.
   */
   private final StringBuilder name_;
   /**
      Short description (< 40 characters).
   */
   private final StringBuilder description_;
   /**
      Scale to be used for default controls (default=1).
   */
   private float scale_;
   /**
      All menu and submenu entries associated with this marker.
   */
   private final IDLObjectSequence<visualization_msgs.msg.dds.MenuEntry> menu_entries_;
   /**
      List of controls displayed for this marker.
   */
   private final IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarkerControl> controls_;

   public InteractiveMarker()
   {
      header_ = new std_msgs.msg.dds.Header();
      pose_ = new geometry_msgs.msg.dds.Pose();
      name_ = new StringBuilder();
      description_ = new StringBuilder();
      menu_entries_ = new IDLObjectSequence<visualization_msgs.msg.dds.MenuEntry>(visualization_msgs.msg.dds.MenuEntry.class);
      controls_ = new IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarkerControl>(visualization_msgs.msg.dds.InteractiveMarkerControl.class);

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // name_
      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // description_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // scale_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      buffer.writeString(name_);
      buffer.writeString(description_);
      buffer.writeFloat(scale_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      buffer.readString(name_);
      buffer.readString(description_);
      scale_ = buffer.readFloat();

   }

   @Override
   public void set(InteractiveMarker from)
   {
      name_.delete(0, name_.length());
      name_.insert(0, from.name_);
      description_.delete(0, description_.length());
      description_.insert(0, from.description_);
      scale_ = from.scale_;

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public geometry_msgs.msg.dds.Pose getpose()
   {
      return pose_;
   }

   public StringBuilder getname()
   {
      return name_;
   }

   public StringBuilder getdescription()
   {
      return description_;
   }

   public float getscale()
   {
      return scale_;
   }

   public void setscale(float scale_)
   {
      this.scale_ = scale_;
   }

   public IDLObjectSequence<visualization_msgs.msg.dds.MenuEntry> getmenu_entries()
   {
      return menu_entries_;
   }

   public IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarkerControl> getcontrols()
   {
      return controls_;
   }


}