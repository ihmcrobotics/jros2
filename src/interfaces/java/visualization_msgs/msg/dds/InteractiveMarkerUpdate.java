/*
 * This class was automatically generated by jros2
 */
package visualization_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
*/
public class InteractiveMarkerUpdate implements ROS2Message<InteractiveMarkerUpdate>
{
   public static final java.lang.String name = "visualization_msgs::msg::dds_::InteractiveMarkerUpdate_";

   /**
      Identifying string. Must be unique in the topic namespace
      that this server works on.
   */
   private StringBuilder server_id_;
   /**
      Sequence number.
      The client will use this to detect if it has missed an update.
   */
   private long seq_num_;
   /**
      Type holds the purpose of this message.  It must be one of UPDATE or KEEP_ALIVE.
      UPDATE: Incremental update to previous state.
      The sequence number must be 1 higher than for
      the previous update.
      KEEP_ALIVE: Indicates the that the server is still living.
      The sequence number does not increase.
      No payload data should be filled out (markers, poses, or erases).
   */
   public static final byte KEEP_ALIVE = 0;
   public static final byte UPDATE = 1;
   private byte type_;
   /**
      Markers to be added or updated
   */
   private visualization_msgs.msg.dds.InteractiveMarker markers_;
   /**
      Poses of markers that should be moved
   */
   private visualization_msgs.msg.dds.InteractiveMarkerPose poses_;
   /**
      Names of markers to be erased
   */
   private IDLStringSequence erases_;

   public InteractiveMarkerUpdate()
   {
      server_id_ = new StringBuilder();
      markers_ = new visualization_msgs.msg.dds.InteractiveMarker();
      poses_ = new visualization_msgs.msg.dds.InteractiveMarkerPose();
      erases_ = new IDLStringSequence();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // server_id_
      currentAlignment += 8 + CDRBuffer.alignment(currentAlignment, 8); // seq_num_
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // type_
      currentAlignment += erases_.calculateSizeBytes(currentAlignment);

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      buffer.writeString(server_id_);
      buffer.writeLong(seq_num_);
      buffer.writeByte(type_);
      erases_.serialize(buffer);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      buffer.readString(server_id_);
      seq_num_ = buffer.readLong();
      type_ = buffer.readByte();
      erases_.deserialize(buffer);

   }

   @Override
   public java.lang.String getName()
   {
      return name;
   }

   @Override
   public void set(InteractiveMarkerUpdate from)
   {
      server_id_ = from.server_id_;
      seq_num_ = from.seq_num_;
      type_ = from.type_;
      erases_.set(from.erases_);

   }

   public StringBuilder getserver_id()
   {
      return server_id_;
   }

   public void setserver_id(StringBuilder server_id_)
   {
      this.server_id_ = server_id_;
   }
   public long getseq_num()
   {
      return seq_num_;
   }

   public void setseq_num(long seq_num_)
   {
      this.seq_num_ = seq_num_;
   }
   public byte gettype()
   {
      return type_;
   }

   public void settype(byte type_)
   {
      this.type_ = type_;
   }
   public visualization_msgs.msg.dds.InteractiveMarker getmarkers()
   {
      return markers_;
   }

   public visualization_msgs.msg.dds.InteractiveMarkerPose getposes()
   {
      return poses_;
   }

   public IDLStringSequence geterases()
   {
      return erases_;
   }


}