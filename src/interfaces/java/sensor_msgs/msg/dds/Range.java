/*
 * This class was automatically generated by jros2
 */
package sensor_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   Single range reading from an active ranger that emits energy and reports
   one range reading that is valid along an arc at the distance measured.
   This message is  not appropriate for laser scanners. See the LaserScan
   message if you are working with a laser scanner.

   This message also can represent a fixed-distance (binary) ranger.  This
   sensor will have min_range===max_range===distance of detection.
   These sensors follow REP 117 and will output -Inf if the object is detected
   and +Inf if the object is outside of the detection range.
*/
public class Range implements ROS2Message<Range>
{
   public static final java.lang.String name = "sensor_msgs::msg::dds_::Range_";

   private final std_msgs.msg.dds.Header header_;
   /**
      Radiation type enums
      If you want a value added to this list, send an email to the ros-users list
   */
   public static final byte ULTRASOUND = 0;
   public static final byte INFRARED = 1;
   private byte radiation_type_;
   private float field_of_view_;
   private float min_range_;
   private float max_range_;
   private float range_;

   public Range()
   {
      header_ = new std_msgs.msg.dds.Header();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // radiation_type_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // field_of_view_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // min_range_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // max_range_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // range_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      buffer.writeByte(radiation_type_);
      buffer.writeFloat(field_of_view_);
      buffer.writeFloat(min_range_);
      buffer.writeFloat(max_range_);
      buffer.writeFloat(range_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      radiation_type_ = buffer.readByte();
      field_of_view_ = buffer.readFloat();
      min_range_ = buffer.readFloat();
      max_range_ = buffer.readFloat();
      range_ = buffer.readFloat();

   }

   @Override
   public void set(Range from)
   {
      header_.set(from.header_);
      radiation_type_ = from.radiation_type_;
      field_of_view_ = from.field_of_view_;
      min_range_ = from.min_range_;
      max_range_ = from.max_range_;
      range_ = from.range_;

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public byte getradiation_type()
   {
      return radiation_type_;
   }

   public void setradiation_type(byte radiation_type_)
   {
      this.radiation_type_ = radiation_type_;
   }

   public float getfield_of_view()
   {
      return field_of_view_;
   }

   public void setfield_of_view(float field_of_view_)
   {
      this.field_of_view_ = field_of_view_;
   }

   public float getmin_range()
   {
      return min_range_;
   }

   public void setmin_range(float min_range_)
   {
      this.min_range_ = min_range_;
   }

   public float getmax_range()
   {
      return max_range_;
   }

   public void setmax_range(float max_range_)
   {
      this.max_range_ = max_range_;
   }

   public float getrange()
   {
      return range_;
   }

   public void setrange(float range_)
   {
      this.range_ = range_;
   }


}