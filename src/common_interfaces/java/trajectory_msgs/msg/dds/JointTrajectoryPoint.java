/*
 * This class was automatically generated by jros2
 */
package trajectory_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
    Each trajectory point specifies either positions[, velocities[, accelerations]]
    or positions[, effort] for the trajectory to be executed.
    All specified values are in the same order as the joint names in JointTrajectory.msg.
*/
public class JointTrajectoryPoint implements ROS2Message<JointTrajectoryPoint>
{
   public static final String name = "trajectory_msgs::msg::dds_::JointTrajectoryPoint_";

   /**
       Single DOF joint positions for each joint relative to their "0" position.
       The units depend on the specific joint type: radians for revolute or
       continuous joints, and meters for prismatic joints.
   */
   private IDLDoubleSequence positions_;
   /**
       The rate of change in position of each joint. Units are joint type dependent.
       Radians/second for revolute or continuous joints, and meters/second for
       prismatic joints.
   */
   private IDLDoubleSequence velocities_;
   /**
       Rate of change in velocity of each joint. Units are joint type dependent.
       Radians/second^2 for revolute or continuous joints, and meters/second^2 for
       prismatic joints.
   */
   private IDLDoubleSequence accelerations_;
   /**
       The torque or the force to be applied at each joint. For revolute/continuous
       joints effort denotes a torque in newton-meters. For prismatic joints, effort
       denotes a force in newtons.
   */
   private IDLDoubleSequence effort_;

   public JointTrajectoryPoint()
   {
      positions_ = new IDLDoubleSequence();
      velocities_ = new IDLDoubleSequence();
      accelerations_ = new IDLDoubleSequence();
      effort_ = new IDLDoubleSequence();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += positions_.calculateSizeBytes(currentAlignment);
      currentAlignment += velocities_.calculateSizeBytes(currentAlignment);
      currentAlignment += accelerations_.calculateSizeBytes(currentAlignment);
      currentAlignment += effort_.calculateSizeBytes(currentAlignment);

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      positions_.serialize(buffer);
      velocities_.serialize(buffer);
      accelerations_.serialize(buffer);
      effort_.serialize(buffer);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      positions_.deserialize(buffer);
      velocities_.deserialize(buffer);
      accelerations_.deserialize(buffer);
      effort_.deserialize(buffer);

   }

   @Override
   public String getName()
   {
      return name;
   }

   @Override
   public void set(JointTrajectoryPoint from)
   {
      positions_.set(from.positions_);
      velocities_.set(from.velocities_);
      accelerations_.set(from.accelerations_);
      effort_.set(from.effort_);

   }

   public IDLDoubleSequence getpositions()
   {
      return positions_;
   }

   public IDLDoubleSequence getvelocities()
   {
      return velocities_;
   }

   public IDLDoubleSequence getaccelerations()
   {
      return accelerations_;
   }

   public IDLDoubleSequence geteffort()
   {
      return effort_;
   }


}