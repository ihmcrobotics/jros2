/*
 * This class was automatically generated by jros2
 */
package stereo_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
*/
public class DisparityImage implements ROS2Message<DisparityImage>
{
   public static final String name = "stereo_msgs::msg::dds_::DisparityImage_";

   /**
       Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.
   */
   private float f_;
   private float t_;
   /**
       The range of disparities searched.
       In the disparity image, any disparity less than min_disparity is invalid.
       The disparity search range defines the horopter, or 3D volume that the
       stereo algorithm can "see". Points with Z outside of:
           Z_min = fT / max_disparity
           Z_max = fT / min_disparity
       could not be found.
   */
   private float min_disparity_;
   private float max_disparity_;
   /**
       Smallest allowed disparity increment. The smallest achievable depth range
       resolution is delta_Z = (Z^2/fT)*delta_d.
   */
   private float delta_d_;

   public DisparityImage()
   {
   }

   public float getf()
   {
      return f_;
   }

   public void setf(float f_)
   {
      this.f_ = f_;
   }

   public float gett()
   {
      return t_;
   }

   public void sett(float t_)
   {
      this.t_ = t_;
   }

   public float getmin_disparity()
   {
      return min_disparity_;
   }

   public void setmin_disparity(float min_disparity_)
   {
      this.min_disparity_ = min_disparity_;
   }

   public float getmax_disparity()
   {
      return max_disparity_;
   }

   public void setmax_disparity(float max_disparity_)
   {
      this.max_disparity_ = max_disparity_;
   }

   public float getdelta_d()
   {
      return delta_d_;
   }

   public void setdelta_d(float delta_d_)
   {
      this.delta_d_ = delta_d_;
   }


   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // f_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // t_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // min_disparity_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // max_disparity_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // delta_d_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      buffer.writeFloat(f_);
      buffer.writeFloat(t_);
      buffer.writeFloat(min_disparity_);
      buffer.writeFloat(max_disparity_);
      buffer.writeFloat(delta_d_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      f_ = buffer.readFloat();
      t_ = buffer.readFloat();
      min_disparity_ = buffer.readFloat();
      max_disparity_ = buffer.readFloat();
      delta_d_ = buffer.readFloat();

   }

   @Override
   public String getName()
   {
      return name;
   }

   @Override
   public void set(DisparityImage from)
   {
      f_ = from.f_;
      t_ = from.t_;
      min_disparity_ = from.min_disparity_;
      max_disparity_ = from.max_disparity_;
      delta_d_ = from.delta_d_;

   }
}