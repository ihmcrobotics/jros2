/*
 * This class was automatically generated by jros2
 */
package visualization_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
*/
public class Marker implements ROS2Message<Marker>
{
   public static final java.lang.String name = "visualization_msgs::msg::dds_::Marker_";

   /**
      Header for timestamp and frame id.
   */
   private std_msgs.msg.dds.Header header_;
   /**
      Namespace in which to place the object.
      Used in conjunction with id to create a unique name for the object.
   */
   private StringBuilder ns_;
   /**
      Object ID used in conjunction with the namespace for manipulating and deleting the object later.
   */
   private int id_;
   /**
      Type of object.
   */
   private int type_;
   /**
      Action to take; one of:
      - 0 add/modify an object
      - 1 (deprecated)
      - 2 deletes an object (with the given ns and id)
      - 3 deletes all objects (or those with the given ns if any)
   */
   private int action_;
   /**
      Pose of the object with respect the frame_id specified in the header.
   */
   private geometry_msgs.msg.dds.Pose pose_;
   /**
      Scale of the object; 1,1,1 means default (usually 1 meter square).
   */
   private geometry_msgs.msg.dds.Vector3 scale_;
   /**
      Color of the object; in the range: [0.0-1.0]
   */
   private std_msgs.msg.dds.ColorRGBA color_;
   /**
      How long the object should last before being automatically deleted.
      0 indicates forever.
   */
   private builtin_interfaces.msg.dds.Duration lifetime_;
   /**
      If this marker should be frame-locked, i.e. retransformed into its frame every timestep.
   */
   private boolean frame_locked_;
   /**
      Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)
   */
   private geometry_msgs.msg.dds.Point points_;
   /**
      Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)
      The number of colors provided must either be 0 or equal to the number of points provided.
      NOTE: alpha is not yet used
   */
   private std_msgs.msg.dds.ColorRGBA colors_;
   /**
      Texture resource is a special URI that can either reference a texture file in
      a format acceptable to (resource retriever)[https://index.ros.org/p/resource_retriever/]
      or an embedded texture via a string matching the format:
      "embedded://texture_name"
   */
   private StringBuilder texture_resource_;
   /**
      An image to be loaded into the rendering engine as the texture for this marker.
      This will be used iff texture_resource is set to embedded.
   */
   private sensor_msgs.msg.dds.CompressedImage texture_;
   /**
      Location of each vertex within the texture; in the range: [0.0-1.0]
   */
   private visualization_msgs.msg.dds.UVCoordinate uv_coordinates_;
   /**
      Only used for text markers
   */
   private StringBuilder text_;
   /**
      Only used for MESH_RESOURCE markers.
      Similar to texture_resource, mesh_resource uses resource retriever to load a mesh.
      Optionally, a mesh file can be sent in-message via the mesh_file field. If doing so,
      use the following format for mesh_resource:
      "embedded://mesh_name"
   */
   private StringBuilder mesh_resource_;
   private visualization_msgs.msg.dds.MeshFile mesh_file_;
   private boolean mesh_use_embedded_materials_;

   public Marker()
   {
      header_ = new std_msgs.msg.dds.Header();
      ns_ = new StringBuilder();
      pose_ = new geometry_msgs.msg.dds.Pose();
      scale_ = new geometry_msgs.msg.dds.Vector3();
      color_ = new std_msgs.msg.dds.ColorRGBA();
      lifetime_ = new builtin_interfaces.msg.dds.Duration();
      points_ = new geometry_msgs.msg.dds.Point();
      colors_ = new std_msgs.msg.dds.ColorRGBA();
      texture_resource_ = new StringBuilder();
      texture_ = new sensor_msgs.msg.dds.CompressedImage();
      uv_coordinates_ = new visualization_msgs.msg.dds.UVCoordinate();
      text_ = new StringBuilder();
      mesh_resource_ = new StringBuilder();
      mesh_file_ = new visualization_msgs.msg.dds.MeshFile();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // ns_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // id_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // type_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // action_
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // frame_locked_
      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // texture_resource_
      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // text_
      currentAlignment += -1 + CDRBuffer.alignment(currentAlignment, -1); // mesh_resource_
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // mesh_use_embedded_materials_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      buffer.writeString(ns_);
      buffer.writeInt(id_);
      buffer.writeInt(type_);
      buffer.writeInt(action_);
      buffer.writeBoolean(frame_locked_);
      buffer.writeString(texture_resource_);
      buffer.writeString(text_);
      buffer.writeString(mesh_resource_);
      buffer.writeBoolean(mesh_use_embedded_materials_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      buffer.readString(ns_);
      id_ = buffer.readInt();
      type_ = buffer.readInt();
      action_ = buffer.readInt();
      frame_locked_ = buffer.readBoolean();
      buffer.readString(texture_resource_);
      buffer.readString(text_);
      buffer.readString(mesh_resource_);
      mesh_use_embedded_materials_ = buffer.readBoolean();

   }

   @Override
   public java.lang.String getName()
   {
      return name;
   }

   @Override
   public void set(Marker from)
   {
      ns_ = from.ns_;
      id_ = from.id_;
      type_ = from.type_;
      action_ = from.action_;
      frame_locked_ = from.frame_locked_;
      texture_resource_ = from.texture_resource_;
      text_ = from.text_;
      mesh_resource_ = from.mesh_resource_;
      mesh_use_embedded_materials_ = from.mesh_use_embedded_materials_;

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public StringBuilder getns()
   {
      return ns_;
   }

   public void setns(StringBuilder ns_)
   {
      this.ns_ = ns_;
   }

   public int getid()
   {
      return id_;
   }

   public void setid(int id_)
   {
      this.id_ = id_;
   }

   public int gettype()
   {
      return type_;
   }

   public void settype(int type_)
   {
      this.type_ = type_;
   }

   public int getaction()
   {
      return action_;
   }

   public void setaction(int action_)
   {
      this.action_ = action_;
   }

   public geometry_msgs.msg.dds.Pose getpose()
   {
      return pose_;
   }

   public geometry_msgs.msg.dds.Vector3 getscale()
   {
      return scale_;
   }

   public std_msgs.msg.dds.ColorRGBA getcolor()
   {
      return color_;
   }

   public builtin_interfaces.msg.dds.Duration getlifetime()
   {
      return lifetime_;
   }

   public boolean getframe_locked()
   {
      return frame_locked_;
   }

   public void setframe_locked(boolean frame_locked_)
   {
      this.frame_locked_ = frame_locked_;
   }

   public geometry_msgs.msg.dds.Point getpoints()
   {
      return points_;
   }

   public std_msgs.msg.dds.ColorRGBA getcolors()
   {
      return colors_;
   }

   public StringBuilder gettexture_resource()
   {
      return texture_resource_;
   }

   public void settexture_resource(StringBuilder texture_resource_)
   {
      this.texture_resource_ = texture_resource_;
   }

   public sensor_msgs.msg.dds.CompressedImage gettexture()
   {
      return texture_;
   }

   public visualization_msgs.msg.dds.UVCoordinate getuv_coordinates()
   {
      return uv_coordinates_;
   }

   public StringBuilder gettext()
   {
      return text_;
   }

   public void settext(StringBuilder text_)
   {
      this.text_ = text_;
   }

   public StringBuilder getmesh_resource()
   {
      return mesh_resource_;
   }

   public void setmesh_resource(StringBuilder mesh_resource_)
   {
      this.mesh_resource_ = mesh_resource_;
   }

   public visualization_msgs.msg.dds.MeshFile getmesh_file()
   {
      return mesh_file_;
   }

   public boolean getmesh_use_embedded_materials()
   {
      return mesh_use_embedded_materials_;
   }

   public void setmesh_use_embedded_materials(boolean mesh_use_embedded_materials_)
   {
      this.mesh_use_embedded_materials_ = mesh_use_embedded_materials_;
   }


}