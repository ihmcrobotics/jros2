/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.
 *
 * Original .msg file content (sensor_msgs/Imu.msg):

# This is a message to hold data from an IMU (Inertial Measurement Unit)
#
# Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec
#
# If the covariance of the measurement is known, it should be filled in (if all you know is the
# variance of each measurement, e.g. from the datasheet, just put those along the diagonal)
# A covariance matrix of all zeros will be interpreted as "covariance unknown", and to use the
# data a covariance will have to be assumed or gotten from some other source
#
# If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an
# orientation estimate), please set element 0 of the associated covariance matrix to -1
# If you are interpreting this message, please check for a value of -1 in the first element of each
# covariance matrix, and disregard the associated estimate.

std_msgs/Header header

geometry_msgs/Quaternion orientation
float64[9] orientation_covariance # Row major about x, y, z axes

geometry_msgs/Vector3 angular_velocity
float64[9] angular_velocity_covariance # Row major about x, y, z axes

geometry_msgs/Vector3 linear_acceleration
float64[9] linear_acceleration_covariance # Row major x, y z


 */
package sensor_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   This is a message to hold data from an IMU (Inertial Measurement Unit)

   Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec

   If the covariance of the measurement is known, it should be filled in (if all you know is the
   variance of each measurement, e.g. from the datasheet, just put those along the diagonal)
   A covariance matrix of all zeros will be interpreted as "covariance unknown", and to use the
   data a covariance will have to be assumed or gotten from some other source

   If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an
   orientation estimate), please set element 0 of the associated covariance matrix to -1
   If you are interpreting this message, please check for a value of -1 in the first element of each
   covariance matrix, and disregard the associated estimate.
*/
public class Imu implements ROS2Message<Imu>
{
   public static final java.lang.String name = "sensor_msgs::msg::dds_::Imu_";

   private final std_msgs.msg.dds.Header header_;
   private final geometry_msgs.msg.dds.Quaternion orientation_;
   private final double[] orientation_covariance_;
   private final geometry_msgs.msg.dds.Vector3 angular_velocity_;
   private final double[] angular_velocity_covariance_;
   private final geometry_msgs.msg.dds.Vector3 linear_acceleration_;
   private final double[] linear_acceleration_covariance_;

   public Imu()
   {
      header_ = new std_msgs.msg.dds.Header();
      orientation_ = new geometry_msgs.msg.dds.Quaternion();
      orientation_covariance_ = new double[9];
      angular_velocity_ = new geometry_msgs.msg.dds.Vector3();
      angular_velocity_covariance_ = new double[9];
      linear_acceleration_ = new geometry_msgs.msg.dds.Vector3();
      linear_acceleration_covariance_ = new double[9];

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += orientation_.calculateSizeBytes(currentAlignment);
      currentAlignment += (9 * 8) + CDRBuffer.alignment(currentAlignment, (9 * 8)); // orientation_covariance_
      currentAlignment += angular_velocity_.calculateSizeBytes(currentAlignment);
      currentAlignment += (9 * 8) + CDRBuffer.alignment(currentAlignment, (9 * 8)); // angular_velocity_covariance_
      currentAlignment += linear_acceleration_.calculateSizeBytes(currentAlignment);
      currentAlignment += (9 * 8) + CDRBuffer.alignment(currentAlignment, (9 * 8)); // linear_acceleration_covariance_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      orientation_.serialize(buffer);
      for (int i = 0; i < orientation_covariance_.length; ++i)
      {
         buffer.writeDouble(orientation_covariance_[i]);
      }
      angular_velocity_.serialize(buffer);
      for (int i = 0; i < angular_velocity_covariance_.length; ++i)
      {
         buffer.writeDouble(angular_velocity_covariance_[i]);
      }
      linear_acceleration_.serialize(buffer);
      for (int i = 0; i < linear_acceleration_covariance_.length; ++i)
      {
         buffer.writeDouble(linear_acceleration_covariance_[i]);
      }

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      orientation_.deserialize(buffer);
      for (int i = 0; i < orientation_covariance_.length; ++i)
      {
      orientation_covariance_[i] = buffer.readDouble();
      }
      angular_velocity_.deserialize(buffer);
      for (int i = 0; i < angular_velocity_covariance_.length; ++i)
      {
      angular_velocity_covariance_[i] = buffer.readDouble();
      }
      linear_acceleration_.deserialize(buffer);
      for (int i = 0; i < linear_acceleration_covariance_.length; ++i)
      {
      linear_acceleration_covariance_[i] = buffer.readDouble();
      }

   }

   @Override
   public void set(Imu from)
   {
      header_.set(from.header_);
      orientation_.set(from.orientation_);
      for (int i = 0; i < orientation_covariance_.length; ++i)
      {
         orientation_covariance_[i] = from.orientation_covariance_[i];
      }
      angular_velocity_.set(from.angular_velocity_);
      for (int i = 0; i < angular_velocity_covariance_.length; ++i)
      {
         angular_velocity_covariance_[i] = from.angular_velocity_covariance_[i];
      }
      linear_acceleration_.set(from.linear_acceleration_);
      for (int i = 0; i < linear_acceleration_covariance_.length; ++i)
      {
         linear_acceleration_covariance_[i] = from.linear_acceleration_covariance_[i];
      }

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public geometry_msgs.msg.dds.Quaternion getorientation()
   {
      return orientation_;
   }

   public double[] getorientation_covariance()
   {
      return orientation_covariance_;
   }

   public geometry_msgs.msg.dds.Vector3 getangular_velocity()
   {
      return angular_velocity_;
   }

   public double[] getangular_velocity_covariance()
   {
      return angular_velocity_covariance_;
   }

   public geometry_msgs.msg.dds.Vector3 getlinear_acceleration()
   {
      return linear_acceleration_;
   }

   public double[] getlinear_acceleration_covariance()
   {
      return linear_acceleration_covariance_;
   }


}