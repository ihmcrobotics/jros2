/*
 * This class was automatically generated by jros2
 */
package sensor_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   ######################################################################
   Image acquisition info                          #
   ######################################################################
*/
public class CameraInfo implements ROS2Message<CameraInfo>
{
   public static final java.lang.String name = "sensor_msgs::msg::dds_::CameraInfo_";

   /**
      Time of image acquisition, camera coordinate frame ID
   */
   private final std_msgs.msg.dds.Header header_;
   /**
      The image dimensions with which the camera was calibrated.
      Normally this will be the full camera resolution in pixels.
   */
   private int height_;
   private int width_;
   /**
      The distortion model used. Supported models are listed in
      sensor_msgs/distortion_models.hpp. For most cameras, "plumb_bob" - a
      simple model of radial and tangential distortion - is sufficent.
   */
   private final StringBuilder distortion_model_;
   /**
      The distortion parameters, size depending on the distortion model.
      For "plumb_bob", the 5 parameters are: (k1, k2, t1, t2, k3).
   */
   private final IDLDoubleSequence d_;
   /**
      Projection/camera matrix
      [fx'  0  cx' Tx]
      P = [ 0  fy' cy' Ty]
      [ 0   0   1   0]
      By convention, this matrix specifies the intrinsic (camera) matrix
      of the processed (rectified) image. That is, the left 3x3 portion
      is the normal camera intrinsic matrix for the rectified image.
      It projects 3D points in the camera coordinate frame to 2D pixel
      coordinates using the focal lengths (fx', fy') and principal point
      (cx', cy') - these may differ from the values in K.
      For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will
      also have R = the identity and P[1:3,1:3] = K.
      For a stereo pair, the fourth column [Tx Ty 0]' is related to the
      position of the optical center of the second camera in the first
      camera's frame. We assume Tz = 0 so both cameras are in the same
      stereo image plane. The first camera always has Tx = Ty = 0. For
      the right (second) camera of a horizontal stereo pair, Ty = 0 and
      Tx = -fx' * B, where B is the baseline between the cameras.
      Given a 3D point [X Y Z]', the projection (x, y) of the point onto
      the rectified image is given by:
      [u v w]' = P * [X Y Z 1]'
      x = u / w
      y = v / w
      This holds for both images of a stereo pair.
   */
   private final double[] p_;
   /**
      Binning refers here to any camera setting which combines rectangular
      neighborhoods of pixels into larger "super-pixels." It reduces the
      resolution of the output image to
      (width / binning_x) x (height / binning_y).
      The default values binning_x = binning_y = 0 is considered the same
      as binning_x = binning_y = 1 (no subsampling).
   */
   private int binning_x_;
   private int binning_y_;
   /**
      Region of interest (subwindow of full camera resolution), given in
      full resolution (unbinned) image coordinates. A particular ROI
      always denotes the same window of pixels on the camera sensor,
      regardless of binning settings.
      The default setting of roi (all values 0) is considered the same as
      full resolution (roi.width = width, roi.height = height).
   */
   private final sensor_msgs.msg.dds.RegionOfInterest roi_;

   public CameraInfo()
   {
      header_ = new std_msgs.msg.dds.Header();
      distortion_model_ = new StringBuilder();
      d_ = new IDLDoubleSequence();
      p_ = new double[12];
      roi_ = new sensor_msgs.msg.dds.RegionOfInterest();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // height_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // width_
      currentAlignment += (1 * distortion_model_.length()) + CDRBuffer.alignment(currentAlignment, (1 * distortion_model_.length())); // distortion_model_
      currentAlignment += d_.calculateSizeBytes(currentAlignment);
      currentAlignment += (12 * 8) + CDRBuffer.alignment(currentAlignment, (12 * 8)); // p_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // binning_x_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // binning_y_
      currentAlignment += roi_.calculateSizeBytes(currentAlignment);

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      buffer.writeInt(height_);
      buffer.writeInt(width_);
      buffer.writeString(distortion_model_);
      d_.serialize(buffer);
      for (int i = 0; i < p_.length; ++i)
      {
         buffer.writeDouble(p_[i]);
      }
      buffer.writeInt(binning_x_);
      buffer.writeInt(binning_y_);
      roi_.serialize(buffer);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      height_ = buffer.readInt();
      width_ = buffer.readInt();
      buffer.readString(distortion_model_);
      d_.deserialize(buffer);
      for (int i = 0; i < p_.length; ++i)
      {
      p_[i] = buffer.readDouble();
      }
      binning_x_ = buffer.readInt();
      binning_y_ = buffer.readInt();
      roi_.deserialize(buffer);

   }

   @Override
   public void set(CameraInfo from)
   {
      header_.set(from.header_);
      height_ = from.height_;
      width_ = from.width_;
      distortion_model_.delete(0, distortion_model_.length());
      distortion_model_.insert(0, from.distortion_model_);
      d_.set(from.d_);
      for (int i = 0; i < p_.length; ++i)
      {
         p_[i] = from.p_[i];
      }
      binning_x_ = from.binning_x_;
      binning_y_ = from.binning_y_;
      roi_.set(from.roi_);

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public int getheight()
   {
      return height_;
   }

   public void setheight(int height_)
   {
      this.height_ = height_;
   }

   public int getwidth()
   {
      return width_;
   }

   public void setwidth(int width_)
   {
      this.width_ = width_;
   }

   public StringBuilder getdistortion_model()
   {
      return distortion_model_;
   }

   public IDLDoubleSequence getd()
   {
      return d_;
   }

   public double[] getp()
   {
      return p_;
   }

   public int getbinning_x()
   {
      return binning_x_;
   }

   public void setbinning_x(int binning_x_)
   {
      this.binning_x_ = binning_x_;
   }

   public int getbinning_y()
   {
      return binning_y_;
   }

   public void setbinning_y(int binning_y_)
   {
      this.binning_y_ = binning_y_;
   }

   public sensor_msgs.msg.dds.RegionOfInterest getroi()
   {
      return roi_;
   }


}