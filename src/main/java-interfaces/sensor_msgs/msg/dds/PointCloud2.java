/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.

##################################################################################
This file was generated from the following content:
(sensor_msgs/PointCloud2.msg)
##################################################################################
   # This message holds a collection of N-dimensional points, which may
   # contain additional information such as normals, intensity, etc. The
   # point data is stored as a binary blob, its layout described by the
   # contents of the "fields" array.
   #
   # The point cloud data may be organized 2d (image-like) or 1d (unordered).
   # Point clouds organized as 2d images may be produced by camera depth sensors
   # such as stereo or time-of-flight.

   # Time of sensor data acquisition, and the coordinate frame ID (for 3d points).
   std_msgs/Header header

   # 2D structure of the point cloud. If the cloud is unordered, height is
   # 1 and width is the length of the point cloud.
   uint32 height
   uint32 width

   # Describes the channels and their layout in the binary data blob.
   PointField[] fields

   bool    is_bigendian # Is this data bigendian?
   uint32  point_step   # Length of a point in bytes
   uint32  row_step     # Length of a row in bytes
   uint8[] data         # Actual point data, size is (row_step*height)

   bool is_dense        # True if there are no invalid points

##################################################################################

 */
package sensor_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   This message holds a collection of N-dimensional points, which may
   contain additional information such as normals, intensity, etc. The
   point data is stored as a binary blob, its layout described by the
   contents of the "fields" array.

   The point cloud data may be organized 2d (image-like) or 1d (unordered).
   Point clouds organized as 2d images may be produced by camera depth sensors
   such as stereo or time-of-flight.
*/
public class PointCloud2 implements ROS2Message<PointCloud2>
{
   public static final java.lang.String name = "sensor_msgs::msg::dds_::PointCloud2_";

   /**
      Time of sensor data acquisition, and the coordinate frame ID (for 3d points).
   */
   private final std_msgs.msg.dds.Header header_;
   /**
      2D structure of the point cloud. If the cloud is unordered, height is
      1 and width is the length of the point cloud.
   */
   private int height_;
   private int width_;
   /**
      Describes the channels and their layout in the binary data blob.
   */
   private final IDLObjectSequence<sensor_msgs.msg.dds.PointField> fields_;
   private final IDLByteSequence data_; // Actual point data, size is (row_step*height)
   private boolean is_dense_; // True if there are no invalid points

   public PointCloud2()
   {
      header_ = new std_msgs.msg.dds.Header();
      fields_ = new IDLObjectSequence<sensor_msgs.msg.dds.PointField>(sensor_msgs.msg.dds.PointField.class);
      data_ = new IDLByteSequence();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // height_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // width_
      currentAlignment += fields_.calculateSizeBytes(currentAlignment);
      currentAlignment += data_.calculateSizeBytes(currentAlignment);
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // is_dense_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      buffer.writeInt(height_);
      buffer.writeInt(width_);
      fields_.serialize(buffer);
      data_.serialize(buffer);
      buffer.writeBoolean(is_dense_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      height_ = buffer.readInt();
      width_ = buffer.readInt();
      fields_.deserialize(buffer);
      data_.deserialize(buffer);
      is_dense_ = buffer.readBoolean();

   }

   @Override
   public void set(PointCloud2 from)
   {
      header_.set(from.header_);
      height_ = from.height_;
      width_ = from.width_;
      fields_.set(from.fields_);
      data_.set(from.data_);
      is_dense_ = from.is_dense_;

   }

   public std_msgs.msg.dds.Header getHeader()
   {
      return header_;
   }

   public int getHeight()
   {
      return height_;
   }

   public void setHeight(int height_)
   {
      this.height_ = height_;
   }

   public int getWidth()
   {
      return width_;
   }

   public void setWidth(int width_)
   {
      this.width_ = width_;
   }

   public IDLObjectSequence<sensor_msgs.msg.dds.PointField> getFields()
   {
      return fields_;
   }

   public IDLByteSequence getData()
   {
      return data_;
   }

   public boolean getIsDense()
   {
      return is_dense_;
   }

   public void setIsDense(boolean is_dense_)
   {
      this.is_dense_ = is_dense_;
   }


}