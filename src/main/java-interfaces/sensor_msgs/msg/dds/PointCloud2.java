/*
 * This class was automatically generated by jros2
 */
package sensor_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   This message holds a collection of N-dimensional points, which may
   contain additional information such as normals, intensity, etc. The
   point data is stored as a binary blob, its layout described by the
   contents of the "fields" array.

   The point cloud data may be organized 2d (image-like) or 1d (unordered).
   Point clouds organized as 2d images may be produced by camera depth sensors
   such as stereo or time-of-flight.
*/
public class PointCloud2 implements ROS2Message<PointCloud2>
{
   public static final java.lang.String name = "sensor_msgs::msg::dds_::PointCloud2_";

   /**
      Time of sensor data acquisition, and the coordinate frame ID (for 3d points).
   */
   private final std_msgs.msg.dds.Header header_;
   /**
      2D structure of the point cloud. If the cloud is unordered, height is
      1 and width is the length of the point cloud.
   */
   private int height_;
   private int width_;
   /**
      Describes the channels and their layout in the binary data blob.
   */
   private final IDLObjectSequence<sensor_msgs.msg.dds.PointField> fields_;
   private final IDLByteSequence data_;
   private boolean is_dense_;

   public PointCloud2()
   {
      header_ = new std_msgs.msg.dds.Header();
      fields_ = new IDLObjectSequence<sensor_msgs.msg.dds.PointField>(sensor_msgs.msg.dds.PointField.class);
      data_ = new IDLByteSequence();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // height_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // width_
      currentAlignment += fields_.calculateSizeBytes(currentAlignment);
      currentAlignment += data_.calculateSizeBytes(currentAlignment);
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // is_dense_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      buffer.writeInt(height_);
      buffer.writeInt(width_);
      fields_.serialize(buffer);
      data_.serialize(buffer);
      buffer.writeBoolean(is_dense_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      height_ = buffer.readInt();
      width_ = buffer.readInt();
      fields_.deserialize(buffer);
      data_.deserialize(buffer);
      is_dense_ = buffer.readBoolean();

   }

   @Override
   public void set(PointCloud2 from)
   {
      header_.set(from.header_);
      height_ = from.height_;
      width_ = from.width_;
      fields_.set(from.fields_);
      data_.set(from.data_);
      is_dense_ = from.is_dense_;

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public int getheight()
   {
      return height_;
   }

   public void setheight(int height_)
   {
      this.height_ = height_;
   }

   public int getwidth()
   {
      return width_;
   }

   public void setwidth(int width_)
   {
      this.width_ = width_;
   }

   public IDLObjectSequence<sensor_msgs.msg.dds.PointField> getfields()
   {
      return fields_;
   }

   public IDLByteSequence getdata()
   {
      return data_;
   }

   public boolean getis_dense()
   {
      return is_dense_;
   }

   public void setis_dense(boolean is_dense_)
   {
      this.is_dense_ = is_dense_;
   }


}