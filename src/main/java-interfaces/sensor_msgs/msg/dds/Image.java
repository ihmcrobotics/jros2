/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.

##################################################################################
This file was generated from the following content:
(sensor_msgs/Image.msg)
##################################################################################
   # This message contains an uncompressed image
   # (0, 0) is at top-left corner of image

   std_msgs/Header header # Header timestamp should be acquisition time of image
                                # Header frame_id should be optical frame of camera
                                # origin of frame should be optical center of cameara
                                # +x should point to the right in the image
                                # +y should point down in the image
                                # +z should point into to plane of the image
                                # If the frame_id here and the frame_id of the CameraInfo
                                # message associated with the image conflict
                                # the behavior is undefined

   uint32 height                # image height, that is, number of rows
   uint32 width                 # image width, that is, number of columns

   # The legal values for encoding are in file src/image_encodings.cpp
   # If you want to standardize a new string format, join
   # ros-users@lists.ros.org and send an email proposing a new encoding.

   string encoding       # Encoding of pixels -- channel meaning, ordering, size
                         # taken from the list of strings in include/sensor_msgs/image_encodings.hpp

   uint8 is_bigendian    # is this data bigendian?
   uint32 step           # Full row length in bytes
   uint8[] data          # actual matrix data, size is (step * rows)

##################################################################################

 */
package sensor_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   This message contains an uncompressed image
   (0, 0) is at top-left corner of image
*/
public class Image implements ROS2Message<Image>
{
   public static final java.lang.String name = "sensor_msgs::msg::dds_::Image_";

   private final std_msgs.msg.dds.Header header_; // Header timestamp should be acquisition time of image
   private int height_; // image height, that is, number of rows
   private int width_; // image width, that is, number of columns
   private final StringBuilder encoding_; // Encoding of pixels -- channel meaning, ordering, size
   private byte is_bigendian_; // is this data bigendian?
   private int step_; // Full row length in bytes
   private final IDLByteSequence data_; // actual matrix data, size is (step * rows)

   public Image()
   {
      header_ = new std_msgs.msg.dds.Header();
      encoding_ = new StringBuilder();
      data_ = new IDLByteSequence();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // height_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // width_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4) + encoding_.length() + 1;
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // is_bigendian_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // step_
      currentAlignment += data_.calculateSizeBytes(currentAlignment);

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      buffer.writeInt(height_);
      buffer.writeInt(width_);
      buffer.writeString(encoding_);
      buffer.writeByte(is_bigendian_);
      buffer.writeInt(step_);
      data_.serialize(buffer);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      height_ = buffer.readInt();
      width_ = buffer.readInt();
      buffer.readString(encoding_);
      is_bigendian_ = buffer.readByte();
      step_ = buffer.readInt();
      data_.deserialize(buffer);

   }

   @Override
   public void set(Image from)
   {
      header_.set(from.header_);
      height_ = from.height_;
      width_ = from.width_;
      encoding_.delete(0, encoding_.length());
      encoding_.insert(0, from.encoding_);
      is_bigendian_ = from.is_bigendian_;
      step_ = from.step_;
      data_.set(from.data_);

   }

   public std_msgs.msg.dds.Header getHeader()
   {
      return header_;
   }

   public int getHeight()
   {
      return height_;
   }

   public void setHeight(int height_)
   {
      this.height_ = height_;
   }

   public int getWidth()
   {
      return width_;
   }

   public void setWidth(int width_)
   {
      this.width_ = width_;
   }

   public StringBuilder getEncoding()
   {
      return encoding_;
   }

   public byte getIsBigendian()
   {
      return is_bigendian_;
   }

   public void setIsBigendian(byte is_bigendian_)
   {
      this.is_bigendian_ = is_bigendian_;
   }

   public int getStep()
   {
      return step_;
   }

   public void setStep(int step_)
   {
      this.step_ = step_;
   }

   public IDLByteSequence getData()
   {
      return data_;
   }


}