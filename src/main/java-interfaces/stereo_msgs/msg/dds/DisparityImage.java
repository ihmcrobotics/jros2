/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.

##################################################################################
This file was generated from the following content:
(stereo_msgs/DisparityImage.msg)
##################################################################################
   # Separate header for compatibility with current TimeSynchronizer.
   # Likely to be removed in a later release, use image.header instead.
   std_msgs/Header header

   # Floating point disparity image. The disparities are pre-adjusted for any
   # x-offset between the principal points of the two cameras (in the case
   # that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)
   sensor_msgs/Image image

   # Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.
   float32 f # Focal length, pixels
   float32 t # Baseline, world units

   # Subwindow of (potentially) valid disparity values.
   sensor_msgs/RegionOfInterest valid_window

   # The range of disparities searched.
   # In the disparity image, any disparity less than min_disparity is invalid.
   # The disparity search range defines the horopter, or 3D volume that the
   # stereo algorithm can "see". Points with Z outside of:
   #     Z_min = fT / max_disparity
   #     Z_max = fT / min_disparity
   # could not be found.
   float32 min_disparity
   float32 max_disparity

   # Smallest allowed disparity increment. The smallest achievable depth range
   # resolution is delta_Z = (Z^2/fT)*delta_d.
   float32 delta_d

##################################################################################

 */
package stereo_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

public class DisparityImage implements ROS2Message<DisparityImage>
{
   public static final java.lang.String name = "stereo_msgs::msg::dds_::DisparityImage_";

   /**
      Separate header for compatibility with current TimeSynchronizer.
      Likely to be removed in a later release, use image.header instead.
   */
   private final std_msgs.msg.dds.Header header_;
   /**
      Floating point disparity image. The disparities are pre-adjusted for any
      x-offset between the principal points of the two cameras (in the case
      that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)
   */
   private final sensor_msgs.msg.dds.Image image_;
   /**
      Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.
   */
   private float f_;
   private float t_;
   /**
      Subwindow of (potentially) valid disparity values.
   */
   private final sensor_msgs.msg.dds.RegionOfInterest valid_window_;
   /**
      The range of disparities searched.
      In the disparity image, any disparity less than min_disparity is invalid.
      The disparity search range defines the horopter, or 3D volume that the
      stereo algorithm can "see". Points with Z outside of:
      Z_min = fT / max_disparity
      Z_max = fT / min_disparity
      could not be found.
   */
   private float min_disparity_;
   private float max_disparity_;
   /**
      Smallest allowed disparity increment. The smallest achievable depth range
      resolution is delta_Z = (Z^2/fT)*delta_d.
   */
   private float delta_d_;

   public DisparityImage()
   {
      header_ = new std_msgs.msg.dds.Header();
      image_ = new sensor_msgs.msg.dds.Image();
      valid_window_ = new sensor_msgs.msg.dds.RegionOfInterest();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += image_.calculateSizeBytes(currentAlignment);
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // f_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // t_
      currentAlignment += valid_window_.calculateSizeBytes(currentAlignment);
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // min_disparity_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // max_disparity_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // delta_d_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      image_.serialize(buffer);
      buffer.writeFloat(f_);
      buffer.writeFloat(t_);
      valid_window_.serialize(buffer);
      buffer.writeFloat(min_disparity_);
      buffer.writeFloat(max_disparity_);
      buffer.writeFloat(delta_d_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      image_.deserialize(buffer);
      f_ = buffer.readFloat();
      t_ = buffer.readFloat();
      valid_window_.deserialize(buffer);
      min_disparity_ = buffer.readFloat();
      max_disparity_ = buffer.readFloat();
      delta_d_ = buffer.readFloat();

   }

   @Override
   public void set(DisparityImage from)
   {
      header_.set(from.header_);
      image_.set(from.image_);
      f_ = from.f_;
      t_ = from.t_;
      valid_window_.set(from.valid_window_);
      min_disparity_ = from.min_disparity_;
      max_disparity_ = from.max_disparity_;
      delta_d_ = from.delta_d_;

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public sensor_msgs.msg.dds.Image getimage()
   {
      return image_;
   }

   public float getf()
   {
      return f_;
   }

   public void setf(float f_)
   {
      this.f_ = f_;
   }

   public float gett()
   {
      return t_;
   }

   public void sett(float t_)
   {
      this.t_ = t_;
   }

   public sensor_msgs.msg.dds.RegionOfInterest getvalid_window()
   {
      return valid_window_;
   }

   public float getmin_disparity()
   {
      return min_disparity_;
   }

   public void setmin_disparity(float min_disparity_)
   {
      this.min_disparity_ = min_disparity_;
   }

   public float getmax_disparity()
   {
      return max_disparity_;
   }

   public void setmax_disparity(float max_disparity_)
   {
      this.max_disparity_ = max_disparity_;
   }

   public float getdelta_d()
   {
      return delta_d_;
   }

   public void setdelta_d(float delta_d_)
   {
      this.delta_d_ = delta_d_;
   }


}