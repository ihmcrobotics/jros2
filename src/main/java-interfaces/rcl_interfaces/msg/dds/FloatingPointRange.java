/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.

##################################################################################
This file was generated from the following content:
(rcl_interfaces/FloatingPointRange.msg)
##################################################################################
   # Represents bounds and a step value for a floating point typed parameter.

   # Start value for valid values, inclusive.
   float64 from_value

   # End value for valid values, inclusive.
   float64 to_value

   # Size of valid steps between the from and to bound.
   # 
   # Step is considered to be a magnitude, therefore negative values are treated
   # the same as positive values, and a step value of zero implies a continuous
   # range of values.
   #
   # Ideally, the step would be less than or equal to the distance between the
   # bounds, as well as an even multiple of the distance between the bounds, but
   # neither are required.
   #
   # If the absolute value of the step is larger than or equal to the distance
   # between the two bounds, then the bounds will be the only valid values. e.g. if
   # the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the
   # valid values will be 1.0 and 2.0.
   #
   # If the step is less than the distance between the bounds, but the distance is
   # not a multiple of the step, then the "to" bound will always be a valid value,
   # e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}
   # then the valid values will be 2.0, 4.0, and 5.0.
   float64 step

##################################################################################

 */
package rcl_interfaces.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   Represents bounds and a step value for a floating point typed parameter.
*/
public class FloatingPointRange implements ROS2Message<FloatingPointRange>
{
   public static final java.lang.String name = "rcl_interfaces::msg::dds_::FloatingPointRange_";

   /**
      Start value for valid values, inclusive.
   */
   private double from_value_;
   /**
      End value for valid values, inclusive.
   */
   private double to_value_;
   /**
      Size of valid steps between the from and to bound.

      Step is considered to be a magnitude, therefore negative values are treated
      the same as positive values, and a step value of zero implies a continuous
      range of values.

      Ideally, the step would be less than or equal to the distance between the
      bounds, as well as an even multiple of the distance between the bounds, but
      neither are required.

      If the absolute value of the step is larger than or equal to the distance
      between the two bounds, then the bounds will be the only valid values. e.g. if
      the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the
      valid values will be 1.0 and 2.0.

      If the step is less than the distance between the bounds, but the distance is
      not a multiple of the step, then the "to" bound will always be a valid value,
      e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}
      then the valid values will be 2.0, 4.0, and 5.0.
   */
   private double step_;

   public FloatingPointRange()
   {
   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += 8 + CDRBuffer.alignment(currentAlignment, 8); // from_value_
      currentAlignment += 8 + CDRBuffer.alignment(currentAlignment, 8); // to_value_
      currentAlignment += 8 + CDRBuffer.alignment(currentAlignment, 8); // step_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      buffer.writeDouble(from_value_);
      buffer.writeDouble(to_value_);
      buffer.writeDouble(step_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      from_value_ = buffer.readDouble();
      to_value_ = buffer.readDouble();
      step_ = buffer.readDouble();

   }

   @Override
   public void set(FloatingPointRange from)
   {
      from_value_ = from.from_value_;
      to_value_ = from.to_value_;
      step_ = from.step_;

   }

   public double getFromValue()
   {
      return from_value_;
   }

   public void setFromValue(double from_value_)
   {
      this.from_value_ = from_value_;
   }

   public double getToValue()
   {
      return to_value_;
   }

   public void setToValue(double to_value_)
   {
      this.to_value_ = to_value_;
   }

   public double getStep()
   {
      return step_;
   }

   public void setStep(double step_)
   {
      this.step_ = step_;
   }


}