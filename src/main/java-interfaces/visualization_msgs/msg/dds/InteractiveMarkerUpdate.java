/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.

##################################################################################
This file was generated from the following content:
(visualization_msgs/InteractiveMarkerUpdate.msg)
##################################################################################

   # Identifying string. Must be unique in the topic namespace
   # that this server works on.
   string server_id

   # Sequence number.
   # The client will use this to detect if it has missed an update.
   uint64 seq_num

   # Type holds the purpose of this message.  It must be one of UPDATE or KEEP_ALIVE.
   # UPDATE: Incremental update to previous state.
   #         The sequence number must be 1 higher than for
   #         the previous update.
   # KEEP_ALIVE: Indicates the that the server is still living.
   #             The sequence number does not increase.
   #             No payload data should be filled out (markers, poses, or erases).
   uint8 KEEP_ALIVE = 0
   uint8 UPDATE = 1

   uint8 type

   # Note: No guarantees on the order of processing.
   #       Contents must be kept consistent by sender.

   # Markers to be added or updated
   InteractiveMarker[] markers

   # Poses of markers that should be moved
   InteractiveMarkerPose[] poses

   # Names of markers to be erased
   string[] erases

##################################################################################

 */
package visualization_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
*/
public class InteractiveMarkerUpdate implements ROS2Message<InteractiveMarkerUpdate>
{
   public static final java.lang.String name = "visualization_msgs::msg::dds_::InteractiveMarkerUpdate_";

   /**
      Identifying string. Must be unique in the topic namespace
      that this server works on.
   */
   private final StringBuilder server_id_;
   /**
      Sequence number.
      The client will use this to detect if it has missed an update.
   */
   private long seq_num_;
   /**
      Type holds the purpose of this message.  It must be one of UPDATE or KEEP_ALIVE.
      UPDATE: Incremental update to previous state.
      The sequence number must be 1 higher than for
      the previous update.
      KEEP_ALIVE: Indicates the that the server is still living.
      The sequence number does not increase.
      No payload data should be filled out (markers, poses, or erases).
   */
   public static final byte KEEP_ALIVE = 0;
   public static final byte UPDATE = 1;
   private byte type_;
   /**
      Markers to be added or updated
   */
   private final IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarker> markers_;
   /**
      Poses of markers that should be moved
   */
   private final IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarkerPose> poses_;
   /**
      Names of markers to be erased
   */
   private final IDLStringSequence erases_;

   public InteractiveMarkerUpdate()
   {
      server_id_ = new StringBuilder();
      markers_ = new IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarker>(visualization_msgs.msg.dds.InteractiveMarker.class);
      poses_ = new IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarkerPose>(visualization_msgs.msg.dds.InteractiveMarkerPose.class);
      erases_ = new IDLStringSequence();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4) + server_id_.length() + 1;
      currentAlignment += 8 + CDRBuffer.alignment(currentAlignment, 8); // seq_num_
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // type_
      currentAlignment += markers_.calculateSizeBytes(currentAlignment);
      currentAlignment += poses_.calculateSizeBytes(currentAlignment);
      currentAlignment += erases_.calculateSizeBytes(currentAlignment);

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      buffer.writeString(server_id_);
      buffer.writeLong(seq_num_);
      buffer.writeByte(type_);
      markers_.serialize(buffer);
      poses_.serialize(buffer);
      erases_.serialize(buffer);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      buffer.readString(server_id_);
      seq_num_ = buffer.readLong();
      type_ = buffer.readByte();
      markers_.deserialize(buffer);
      poses_.deserialize(buffer);
      erases_.deserialize(buffer);

   }

   @Override
   public void set(InteractiveMarkerUpdate from)
   {
      server_id_.delete(0, server_id_.length());
      server_id_.insert(0, from.server_id_);
      seq_num_ = from.seq_num_;
      type_ = from.type_;
      markers_.set(from.markers_);
      poses_.set(from.poses_);
      erases_.set(from.erases_);

   }

   public StringBuilder getServerId()
   {
      return server_id_;
   }

   public long getSeqNum()
   {
      return seq_num_;
   }

   public void setSeqNum(long seq_num_)
   {
      this.seq_num_ = seq_num_;
   }

   public byte getType()
   {
      return type_;
   }

   public void setType(byte type_)
   {
      this.type_ = type_;
   }

   public IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarker> getMarkers()
   {
      return markers_;
   }

   public IDLObjectSequence<visualization_msgs.msg.dds.InteractiveMarkerPose> getPoses()
   {
      return poses_;
   }

   public IDLStringSequence getErases()
   {
      return erases_;
   }


}