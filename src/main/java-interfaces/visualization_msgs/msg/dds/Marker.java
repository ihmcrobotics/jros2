/*
 * This class was automatically generated by jros2.
 * Do not modify this file directly.

##################################################################################
This file was generated from the following content:
(visualization_msgs/Marker.msg)
##################################################################################
   # See:
   #  - http://www.ros.org/wiki/rviz/DisplayTypes/Marker
   #  - http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes
   #
   # for more information on using this message with rviz.

   int32 ARROW=0
   int32 CUBE=1
   int32 SPHERE=2
   int32 CYLINDER=3
   int32 LINE_STRIP=4
   int32 LINE_LIST=5
   int32 CUBE_LIST=6
   int32 SPHERE_LIST=7
   int32 POINTS=8
   int32 TEXT_VIEW_FACING=9
   int32 MESH_RESOURCE=10
   int32 TRIANGLE_LIST=11

   int32 ADD=0
   int32 MODIFY=0
   int32 DELETE=2
   int32 DELETEALL=3

   # Header for timestamp and frame id.
   std_msgs/Header header
   # Namespace in which to place the object.
   # Used in conjunction with id to create a unique name for the object.
   string ns
   # Object ID used in conjunction with the namespace for manipulating and deleting the object later.
   int32 id
   # Type of object.
   int32 type
   # Action to take; one of:
   #  - 0 add/modify an object
   #  - 1 (deprecated)
   #  - 2 deletes an object (with the given ns and id)
   #  - 3 deletes all objects (or those with the given ns if any)
   int32 action
   # Pose of the object with respect the frame_id specified in the header.
   geometry_msgs/Pose pose
   # Scale of the object; 1,1,1 means default (usually 1 meter square).
   geometry_msgs/Vector3 scale
   # Color of the object; in the range: [0.0-1.0]
   std_msgs/ColorRGBA color
   # How long the object should last before being automatically deleted.
   # 0 indicates forever.
   builtin_interfaces/Duration lifetime
   # If this marker should be frame-locked, i.e. retransformed into its frame every timestep.
   bool frame_locked

   # Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)
   geometry_msgs/Point[] points
   # Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)
   # The number of colors provided must either be 0 or equal to the number of points provided.
   # NOTE: alpha is not yet used
   std_msgs/ColorRGBA[] colors

   # Texture resource is a special URI that can either reference a texture file in
   # a format acceptable to (resource retriever)[https://index.ros.org/p/resource_retriever/]
   # or an embedded texture via a string matching the format:
   #   "embedded://texture_name"
   string texture_resource
   # An image to be loaded into the rendering engine as the texture for this marker.
   # This will be used iff texture_resource is set to embedded.
   sensor_msgs/CompressedImage texture
   # Location of each vertex within the texture; in the range: [0.0-1.0]
   UVCoordinate[] uv_coordinates

   # Only used for text markers
   string text

   # Only used for MESH_RESOURCE markers.
   # Similar to texture_resource, mesh_resource uses resource retriever to load a mesh.
   # Optionally, a mesh file can be sent in-message via the mesh_file field. If doing so,
   # use the following format for mesh_resource:
   #   "embedded://mesh_name"
   string mesh_resource
   MeshFile mesh_file
   bool mesh_use_embedded_materials

##################################################################################

 */
package visualization_msgs.msg.dds;

import us.ihmc.fastddsjava.cdr.CDRBuffer;
import us.ihmc.fastddsjava.cdr.idl.*;
import us.ihmc.jros2.ROS2Message;

/**
   See:
   - http://www.ros.org/wiki/rviz/DisplayTypes/Marker
   - http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes

   for more information on using this message with rviz.
*/
public class Marker implements ROS2Message<Marker>
{
   public static final java.lang.String name = "visualization_msgs::msg::dds_::Marker_";

   public static final int ARROW = 0;
   public static final int CUBE = 1;
   public static final int SPHERE = 2;
   public static final int CYLINDER = 3;
   public static final int LINE_STRIP = 4;
   public static final int LINE_LIST = 5;
   public static final int CUBE_LIST = 6;
   public static final int SPHERE_LIST = 7;
   public static final int POINTS = 8;
   public static final int TEXT_VIEW_FACING = 9;
   public static final int MESH_RESOURCE = 10;
   public static final int TRIANGLE_LIST = 11;
   public static final int ADD = 0;
   public static final int MODIFY = 0;
   public static final int DELETE = 2;
   public static final int DELETEALL = 3;
   /**
      Header for timestamp and frame id.
   */
   private final std_msgs.msg.dds.Header header_;
   /**
      Namespace in which to place the object.
      Used in conjunction with id to create a unique name for the object.
   */
   private final StringBuilder ns_;
   /**
      Object ID used in conjunction with the namespace for manipulating and deleting the object later.
   */
   private int id_;
   /**
      Type of object.
   */
   private int type_;
   /**
      Action to take; one of:
      - 0 add/modify an object
      - 1 (deprecated)
      - 2 deletes an object (with the given ns and id)
      - 3 deletes all objects (or those with the given ns if any)
   */
   private int action_;
   /**
      Pose of the object with respect the frame_id specified in the header.
   */
   private final geometry_msgs.msg.dds.Pose pose_;
   /**
      Scale of the object; 1,1,1 means default (usually 1 meter square).
   */
   private final geometry_msgs.msg.dds.Vector3 scale_;
   /**
      Color of the object; in the range: [0.0-1.0]
   */
   private final std_msgs.msg.dds.ColorRGBA color_;
   /**
      How long the object should last before being automatically deleted.
      0 indicates forever.
   */
   private final builtin_interfaces.msg.dds.Duration lifetime_;
   /**
      If this marker should be frame-locked, i.e. retransformed into its frame every timestep.
   */
   private boolean frame_locked_;
   /**
      Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)
   */
   private final IDLObjectSequence<geometry_msgs.msg.dds.Point> points_;
   /**
      Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, etc.)
      The number of colors provided must either be 0 or equal to the number of points provided.
      NOTE: alpha is not yet used
   */
   private final IDLObjectSequence<std_msgs.msg.dds.ColorRGBA> colors_;
   /**
      Texture resource is a special URI that can either reference a texture file in
      a format acceptable to (resource retriever)[https://index.ros.org/p/resource_retriever/]
      or an embedded texture via a string matching the format:
      "embedded://texture_name"
   */
   private final StringBuilder texture_resource_;
   /**
      An image to be loaded into the rendering engine as the texture for this marker.
      This will be used iff texture_resource is set to embedded.
   */
   private final sensor_msgs.msg.dds.CompressedImage texture_;
   /**
      Location of each vertex within the texture; in the range: [0.0-1.0]
   */
   private final IDLObjectSequence<visualization_msgs.msg.dds.UVCoordinate> uv_coordinates_;
   /**
      Only used for text markers
   */
   private final StringBuilder text_;
   /**
      Only used for MESH_RESOURCE markers.
      Similar to texture_resource, mesh_resource uses resource retriever to load a mesh.
      Optionally, a mesh file can be sent in-message via the mesh_file field. If doing so,
      use the following format for mesh_resource:
      "embedded://mesh_name"
   */
   private final StringBuilder mesh_resource_;
   private final visualization_msgs.msg.dds.MeshFile mesh_file_;
   private boolean mesh_use_embedded_materials_;

   public Marker()
   {
      header_ = new std_msgs.msg.dds.Header();
      ns_ = new StringBuilder();
      pose_ = new geometry_msgs.msg.dds.Pose();
      scale_ = new geometry_msgs.msg.dds.Vector3();
      color_ = new std_msgs.msg.dds.ColorRGBA();
      lifetime_ = new builtin_interfaces.msg.dds.Duration();
      points_ = new IDLObjectSequence<geometry_msgs.msg.dds.Point>(geometry_msgs.msg.dds.Point.class);
      colors_ = new IDLObjectSequence<std_msgs.msg.dds.ColorRGBA>(std_msgs.msg.dds.ColorRGBA.class);
      texture_resource_ = new StringBuilder();
      texture_ = new sensor_msgs.msg.dds.CompressedImage();
      uv_coordinates_ = new IDLObjectSequence<visualization_msgs.msg.dds.UVCoordinate>(visualization_msgs.msg.dds.UVCoordinate.class);
      text_ = new StringBuilder();
      mesh_resource_ = new StringBuilder();
      mesh_file_ = new visualization_msgs.msg.dds.MeshFile();

   }

   @Override
   public int calculateSizeBytes(int currentAlignment)
   {
      int initialAlignment = currentAlignment;

      currentAlignment += header_.calculateSizeBytes(currentAlignment);
      currentAlignment += (1 * ns_.length()) + CDRBuffer.alignment(currentAlignment, (1 * ns_.length())); // ns_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // id_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // type_
      currentAlignment += 4 + CDRBuffer.alignment(currentAlignment, 4); // action_
      currentAlignment += pose_.calculateSizeBytes(currentAlignment);
      currentAlignment += scale_.calculateSizeBytes(currentAlignment);
      currentAlignment += color_.calculateSizeBytes(currentAlignment);
      currentAlignment += lifetime_.calculateSizeBytes(currentAlignment);
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // frame_locked_
      currentAlignment += points_.calculateSizeBytes(currentAlignment);
      currentAlignment += colors_.calculateSizeBytes(currentAlignment);
      currentAlignment += (1 * texture_resource_.length()) + CDRBuffer.alignment(currentAlignment, (1 * texture_resource_.length())); // texture_resource_
      currentAlignment += texture_.calculateSizeBytes(currentAlignment);
      currentAlignment += uv_coordinates_.calculateSizeBytes(currentAlignment);
      currentAlignment += (1 * text_.length()) + CDRBuffer.alignment(currentAlignment, (1 * text_.length())); // text_
      currentAlignment += (1 * mesh_resource_.length()) + CDRBuffer.alignment(currentAlignment, (1 * mesh_resource_.length())); // mesh_resource_
      currentAlignment += mesh_file_.calculateSizeBytes(currentAlignment);
      currentAlignment += 1 + CDRBuffer.alignment(currentAlignment, 1); // mesh_use_embedded_materials_

      return currentAlignment - initialAlignment;
   }

   @Override
   public void serialize(CDRBuffer buffer)
   {
      header_.serialize(buffer);
      buffer.writeString(ns_);
      buffer.writeInt(id_);
      buffer.writeInt(type_);
      buffer.writeInt(action_);
      pose_.serialize(buffer);
      scale_.serialize(buffer);
      color_.serialize(buffer);
      lifetime_.serialize(buffer);
      buffer.writeBoolean(frame_locked_);
      points_.serialize(buffer);
      colors_.serialize(buffer);
      buffer.writeString(texture_resource_);
      texture_.serialize(buffer);
      uv_coordinates_.serialize(buffer);
      buffer.writeString(text_);
      buffer.writeString(mesh_resource_);
      mesh_file_.serialize(buffer);
      buffer.writeBoolean(mesh_use_embedded_materials_);

   }

   @Override
   public void deserialize(CDRBuffer buffer)
   {
      header_.deserialize(buffer);
      buffer.readString(ns_);
      id_ = buffer.readInt();
      type_ = buffer.readInt();
      action_ = buffer.readInt();
      pose_.deserialize(buffer);
      scale_.deserialize(buffer);
      color_.deserialize(buffer);
      lifetime_.deserialize(buffer);
      frame_locked_ = buffer.readBoolean();
      points_.deserialize(buffer);
      colors_.deserialize(buffer);
      buffer.readString(texture_resource_);
      texture_.deserialize(buffer);
      uv_coordinates_.deserialize(buffer);
      buffer.readString(text_);
      buffer.readString(mesh_resource_);
      mesh_file_.deserialize(buffer);
      mesh_use_embedded_materials_ = buffer.readBoolean();

   }

   @Override
   public void set(Marker from)
   {
      header_.set(from.header_);
      ns_.delete(0, ns_.length());
      ns_.insert(0, from.ns_);
      id_ = from.id_;
      type_ = from.type_;
      action_ = from.action_;
      pose_.set(from.pose_);
      scale_.set(from.scale_);
      color_.set(from.color_);
      lifetime_.set(from.lifetime_);
      frame_locked_ = from.frame_locked_;
      points_.set(from.points_);
      colors_.set(from.colors_);
      texture_resource_.delete(0, texture_resource_.length());
      texture_resource_.insert(0, from.texture_resource_);
      texture_.set(from.texture_);
      uv_coordinates_.set(from.uv_coordinates_);
      text_.delete(0, text_.length());
      text_.insert(0, from.text_);
      mesh_resource_.delete(0, mesh_resource_.length());
      mesh_resource_.insert(0, from.mesh_resource_);
      mesh_file_.set(from.mesh_file_);
      mesh_use_embedded_materials_ = from.mesh_use_embedded_materials_;

   }

   public std_msgs.msg.dds.Header getheader()
   {
      return header_;
   }

   public StringBuilder getns()
   {
      return ns_;
   }

   public int getid()
   {
      return id_;
   }

   public void setid(int id_)
   {
      this.id_ = id_;
   }

   public int gettype()
   {
      return type_;
   }

   public void settype(int type_)
   {
      this.type_ = type_;
   }

   public int getaction()
   {
      return action_;
   }

   public void setaction(int action_)
   {
      this.action_ = action_;
   }

   public geometry_msgs.msg.dds.Pose getpose()
   {
      return pose_;
   }

   public geometry_msgs.msg.dds.Vector3 getscale()
   {
      return scale_;
   }

   public std_msgs.msg.dds.ColorRGBA getcolor()
   {
      return color_;
   }

   public builtin_interfaces.msg.dds.Duration getlifetime()
   {
      return lifetime_;
   }

   public boolean getframe_locked()
   {
      return frame_locked_;
   }

   public void setframe_locked(boolean frame_locked_)
   {
      this.frame_locked_ = frame_locked_;
   }

   public IDLObjectSequence<geometry_msgs.msg.dds.Point> getpoints()
   {
      return points_;
   }

   public IDLObjectSequence<std_msgs.msg.dds.ColorRGBA> getcolors()
   {
      return colors_;
   }

   public StringBuilder gettexture_resource()
   {
      return texture_resource_;
   }

   public sensor_msgs.msg.dds.CompressedImage gettexture()
   {
      return texture_;
   }

   public IDLObjectSequence<visualization_msgs.msg.dds.UVCoordinate> getuv_coordinates()
   {
      return uv_coordinates_;
   }

   public StringBuilder gettext()
   {
      return text_;
   }

   public StringBuilder getmesh_resource()
   {
      return mesh_resource_;
   }

   public visualization_msgs.msg.dds.MeshFile getmesh_file()
   {
      return mesh_file_;
   }

   public boolean getmesh_use_embedded_materials()
   {
      return mesh_use_embedded_materials_;
   }

   public void setmesh_use_embedded_materials(boolean mesh_use_embedded_materials_)
   {
      this.mesh_use_embedded_materials_ = mesh_use_embedded_materials_;
   }


}